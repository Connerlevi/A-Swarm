---
# Production-Ready A-SWARM Fast-Path Deployment
# Addresses all blockers: proper code mounting, health checks, security, RBAC
---
apiVersion: v1
kind: Namespace
metadata:
  name: aswarm
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: aswarm-sentinel
  namespace: aswarm
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: aswarm-pheromone
  namespace: aswarm
---
# Sentinel needs leases and events only (nodes removed - cluster scoped)
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: aswarm-sentinel-role
  namespace: aswarm
rules:
- apiGroups: ["coordination.k8s.io"]
  resources: ["leases"]
  verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
- apiGroups: [""]
  resources: ["events"]
  verbs: ["create"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: aswarm-pheromone-role
  namespace: aswarm
rules:
- apiGroups: ["coordination.k8s.io"]
  resources: ["leases"]
  verbs: ["get", "list", "watch"]
- apiGroups: [""]
  resources: ["configmaps"]
  verbs: ["get", "list", "watch", "create", "update", "patch"]
- apiGroups: [""]
  resources: ["events"]
  verbs: ["create"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: aswarm-sentinel-binding
  namespace: aswarm
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: aswarm-sentinel-role
subjects:
- kind: ServiceAccount
  name: aswarm-sentinel
  namespace: aswarm
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: aswarm-pheromone-binding
  namespace: aswarm
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: aswarm-pheromone-role
subjects:
- kind: ServiceAccount
  name: aswarm-pheromone
  namespace: aswarm
---
# Note: Create this secret manually with: 
# kubectl -n aswarm create secret generic aswarm-fastpath-key --from-literal=key="$(openssl rand -base64 32)"
---
apiVersion: v1
kind: Service
metadata:
  name: aswarm-pheromone
  namespace: aswarm
  labels:
    app: aswarm-pheromone
spec:
  selector:
    app: aswarm-pheromone
  ports:
    - name: udp-fastpath
      protocol: UDP
      port: 8888
      targetPort: 8888
  type: ClusterIP
---
# NetworkPolicy: Only Sentinels can send to Pheromone
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-sentinel-to-pheromone
  namespace: aswarm
spec:
  podSelector:
    matchLabels:
      app: aswarm-pheromone
  ingress:
  - from:
    - podSelector:
        matchLabels:
          app: aswarm-sentinel
    ports:
    - protocol: UDP
      port: 8888
  policyTypes: ["Ingress"]
---
# PodDisruptionBudget for Pheromone
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: aswarm-pheromone-pdb
  namespace: aswarm
spec:
  minAvailable: 1
  selector:
    matchLabels:
      app: aswarm-pheromone
---
# Code bundle as Secret (base64 encoded tarball)
apiVersion: v1
kind: Secret
metadata:
  name: aswarm-code-bundle
  namespace: aswarm
type: Opaque
data:
  # This would contain a tarball with all Python code
  # Create with: tar czf - sentinel/ pheromone/ | base64 -w0
  code.tar.gz: |
    H4sIAAAAAAAAA+1Ze1PbSBb9fPwKLlUzU5NdLNmWbZJQqS0BBjxgHBuYZDZblZIt
    # ... (truncated for brevity - in production, include full base64 tarball)
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: aswarm-pheromone
  namespace: aswarm
  labels:
    app: aswarm-pheromone
spec:
  replicas: 1
  selector:
    matchLabels:
      app: aswarm-pheromone
  template:
    metadata:
      labels:
        app: aswarm-pheromone
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "9000"
        prometheus.io/path: "/metrics"
    spec:
      serviceAccountName: aswarm-pheromone
      securityContext:
        runAsNonRoot: true
        runAsUser: 10001
        runAsGroup: 10001
        fsGroup: 10001
        seccompProfile:
          type: RuntimeDefault
      initContainers:
      - name: code-extractor
        image: busybox:1.36
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop: ["ALL"]
        command: ["/bin/sh", "-c"]
        args:
          - |
            echo "Extracting code bundle..."
            base64 -d /secrets/code.tar.gz | tar xzf - -C /app
            echo "Code extraction complete"
        volumeMounts:
        - name: code-secret
          mountPath: /secrets
          readOnly: true
        - name: app-code
          mountPath: /app
      containers:
      - name: pheromone
        image: python:3.11-alpine
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop: ["ALL"]
        command: ["/bin/sh", "-c"]
        args:
          - |
            # Install deps in writable tmp
            cd /tmp
            pip install --no-cache-dir --target=/tmp/deps kubernetes
            export PYTHONPATH=/tmp/deps:/app:$PYTHONPATH
            
            # Create runner with health endpoint
            cat > /tmp/runner.py << 'EOF'
            import os
            import sys
            import time
            import logging
            import threading
            import http.server
            import socketserver
            from datetime import datetime
            
            # Import from extracted code
            sys.path.insert(0, '/app')
            from pheromone.udp_listener import FastPathListener
            
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s [%(levelname)s] %(name)s: %(message)s'
            )
            logger = logging.getLogger('pheromone.main')
            
            # Global state for health checks
            listener = None
            is_degraded = False
            
            def elevation_callback(data, addr):
                """Process elevation signals from Sentinels"""
                logger.info(f"Elevation: {addr[0]} score={data.get('anomaly', {}).get('score', 0):.3f}")
            
            def health_check():
                """Health check logic"""
                if not listener:
                    return False
                stats = listener.get_stats()
                # Check drop rate
                total = stats.get('received', 1)
                dropped = stats.get('dropped_queue_full', 0)
                drop_rate = dropped / total if total > 0 else 0
                global is_degraded
                is_degraded = drop_rate > 0.02  # 2% threshold
                return listener.is_running and not is_degraded
            
            def start_health_server(port=9000):
                """HTTP health endpoint"""
                class HealthHandler(http.server.SimpleHTTPRequestHandler):
                    def do_GET(self):
                        if self.path == "/healthz":
                            if health_check():
                                self.send_response(200)
                                self.send_header('X-ASWARM-DEGRADED', '0')
                            else:
                                self.send_response(503)
                                self.send_header('X-ASWARM-DEGRADED', '1' if is_degraded else '0')
                            self.end_headers()
                            self.wfile.write(b"ok" if health_check() else b"degraded")
                        elif self.path == "/metrics":
                            # Basic Prometheus metrics
                            self.send_response(200)
                            self.end_headers()
                            if listener:
                                stats = listener.get_stats()
                                metrics = f"""# HELP aswarm_udp_received_total Total UDP packets received
            # TYPE aswarm_udp_received_total counter
            aswarm_udp_received_total {stats.get('received', 0)}
            # HELP aswarm_udp_valid_total Total valid packets processed
            # TYPE aswarm_udp_valid_total counter
            aswarm_udp_valid_total {stats.get('valid', 0)}
            # HELP aswarm_udp_dropped_total Packets dropped due to queue full
            # TYPE aswarm_udp_dropped_total counter
            aswarm_udp_dropped_total {stats.get('dropped_queue_full', 0)}
            # HELP aswarm_processing_latency_ms Processing latency P95
            # TYPE aswarm_processing_latency_ms gauge
            aswarm_processing_latency_ms {stats.get('p95_ms', 0)}
            """
                                self.wfile.write(metrics.encode())
                        else:
                            self.send_response(404)
                            self.end_headers()
                    def log_message(self, format, *args):
                        pass  # Silence logs
                
                server = socketserver.TCPServer(("0.0.0.0", port), HealthHandler)
                thread = threading.Thread(target=server.serve_forever, daemon=True)
                thread.start()
                logger.info(f"Health server started on port {port}")
            
            def main():
                global listener
                
                # Configuration from environment
                shared_key = os.environ.get('ASWARM_FASTPATH_KEY', '')
                if not shared_key:
                    logger.error("ASWARM_FASTPATH_KEY not set!")
                    sys.exit(1)
                
                queue_size = int(os.environ.get('ASWARM_QUEUE_SIZE', '10000'))
                workers = int(os.environ.get('ASWARM_WORKERS', '4'))
                
                # Start health endpoint
                start_health_server(9000)
                
                # Create listener
                listener = FastPathListener(
                    bind_addr='0.0.0.0',
                    bind_port=8888,
                    shared_keys={1: shared_key},
                    elevation_callback=elevation_callback,
                    workers=workers,
                    queue_size=queue_size
                )
                
                logger.info(f"Starting Pheromone: queue={queue_size}, workers={workers}")
                listener.start()
                
                # Main loop with stats logging
                try:
                    while True:
                        time.sleep(30)
                        stats = listener.get_stats()
                        logger.info(f"Stats: {stats}")
                except KeyboardInterrupt:
                    logger.info("Shutting down...")
                finally:
                    if listener:
                        listener.stop()
            
            if __name__ == '__main__':
                main()
            EOF
            
            python /tmp/runner.py
        env:
        - name: NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: ASWARM_FASTPATH_KEY
          valueFrom:
            secretKeyRef:
              name: aswarm-fastpath-key
              key: key
        - name: ASWARM_QUEUE_SIZE
          value: "10000"
        - name: ASWARM_WORKERS
          value: "4"
        - name: ASWARM_DROP_POLICY
          value: "drop_oldest"
        - name: ASWARM_RATE_TOKENS_PER_SEC
          value: "50"
        - name: ASWARM_RATE_BUCKET
          value: "100"
        - name: ASWARM_TS_SKEW_MS
          value: "5000"
        ports:
        - name: udp-fastpath
          containerPort: 8888
          protocol: UDP
        - name: health
          containerPort: 9000
          protocol: TCP
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /healthz
            port: 9000
          initialDelaySeconds: 10
          periodSeconds: 15
          timeoutSeconds: 3
        readinessProbe:
          httpGet:
            path: /healthz
            port: 9000
          initialDelaySeconds: 5
          periodSeconds: 10
          timeoutSeconds: 3
        volumeMounts:
        - name: tmp
          mountPath: /tmp
        - name: app-code
          mountPath: /app
          readOnly: true
      volumes:
      - name: tmp
        emptyDir: {}
      - name: app-code
        emptyDir: {}
      - name: code-secret
        secret:
          secretName: aswarm-code-bundle
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: aswarm-sentinel
  namespace: aswarm
  labels:
    app: aswarm-sentinel
spec:
  selector:
    matchLabels:
      app: aswarm-sentinel
  template:
    metadata:
      labels:
        app: aswarm-sentinel
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "9001"
        prometheus.io/path: "/metrics"
    spec:
      serviceAccountName: aswarm-sentinel
      securityContext:
        runAsNonRoot: true
        runAsUser: 10002
        runAsGroup: 10002
        fsGroup: 10002
        seccompProfile:
          type: RuntimeDefault
      initContainers:
      - name: code-extractor
        image: busybox:1.36
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop: ["ALL"]
        command: ["/bin/sh", "-c"]
        args:
          - |
            echo "Extracting code bundle..."
            base64 -d /secrets/code.tar.gz | tar xzf - -C /app
            echo "Code extraction complete"
        volumeMounts:
        - name: code-secret
          mountPath: /secrets
          readOnly: true
        - name: app-code
          mountPath: /app
      containers:
      - name: sentinel
        image: python:3.11-alpine
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop: ["ALL"]
        command: ["/bin/sh", "-c"]
        args:
          - |
            # Install deps in writable tmp
            cd /tmp
            pip install --no-cache-dir --target=/tmp/deps kubernetes numpy
            export PYTHONPATH=/tmp/deps:/app:$PYTHONPATH
            
            # Create runner with health endpoint
            cat > /tmp/runner.py << 'EOF'
            import os
            import sys
            import time
            import json
            import random
            import logging
            import threading
            import http.server
            import socketserver
            from datetime import datetime, timezone
            from kubernetes import client, config
            
            sys.path.insert(0, '/app')
            from sentinel.fast_path import FastPathSender
            
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s [%(levelname)s] %(name)s: %(message)s'
            )
            logger = logging.getLogger('sentinel.telemetry')
            
            # Global state
            sender = None
            is_healthy = True
            
            def health_check():
                return is_healthy and sender is not None
            
            def start_health_server(port=9001):
                """HTTP health endpoint"""
                class HealthHandler(http.server.SimpleHTTPRequestHandler):
                    def do_GET(self):
                        if self.path == "/healthz":
                            if health_check():
                                self.send_response(200)
                            else:
                                self.send_response(503)
                            self.end_headers()
                            self.wfile.write(b"ok" if health_check() else b"unhealthy")
                        elif self.path == "/metrics":
                            self.send_response(200)
                            self.end_headers()
                            # Basic metrics
                            metrics = f"""# HELP aswarm_sentinel_healthy Sentinel health status
            # TYPE aswarm_sentinel_healthy gauge
            aswarm_sentinel_healthy {1 if is_healthy else 0}
            """
                            self.wfile.write(metrics.encode())
                        else:
                            self.send_response(404)
                            self.end_headers()
                    def log_message(self, format, *args):
                        pass
                
                server = socketserver.TCPServer(("0.0.0.0", port), HealthHandler)
                thread = threading.Thread(target=server.serve_forever, daemon=True)
                thread.start()
                logger.info(f"Health server started on port {port}")
            
            class DualPathTelemetry:
                def __init__(self):
                    global sender
                    
                    try:
                        config.load_incluster_config()
                    except:
                        config.load_kube_config()
                    
                    self.coordination_v1 = client.CoordinationV1Api()
                    self.node_name = os.environ.get('NODE_NAME', 'unknown')
                    self.namespace = os.environ.get('NAMESPACE', 'aswarm')
                    
                    # Fast-path configuration
                    fastpath_host = os.environ.get('FASTPATH_HOST', 'aswarm-pheromone')
                    fastpath_port = int(os.environ.get('FASTPATH_PORT', '8888'))
                    fastpath_key = os.environ.get('ASWARM_FASTPATH_KEY', '')
                    
                    if not fastpath_key:
                        logger.error("ASWARM_FASTPATH_KEY not set!")
                        sys.exit(1)
                    
                    sender = self.fastpath_sender = FastPathSender(
                        host=fastpath_host,
                        port=fastpath_port,
                        shared_key=fastpath_key,
                        dupes=int(os.environ.get('ASWARM_DUPES', '3')),
                        gap_ms=int(os.environ.get('ASWARM_GAP_MS', '6'))
                    )
                    
                    logger.info(f"Telemetry initialized: node={self.node_name}, "
                               f"fastpath={fastpath_host}:{fastpath_port}")
                
                def run(self):
                    global is_healthy
                    sequence = 0
                    
                    while True:
                        try:
                            # Generate score
                            base_score = 0.5 + (sequence % 50) / 100.0
                            noise = random.uniform(-0.1, 0.1)
                            score = max(0.0, min(1.0, base_score + noise))
                            
                            # Occasionally high scores
                            if random.random() < 0.05:
                                score = random.uniform(0.90, 0.99)
                            
                            # Update Lease
                            lease_name = f"aswarm-sentinel-{self.node_name}"
                            lease_data = {
                                "apiVersion": "coordination.k8s.io/v1",
                                "kind": "Lease",
                                "metadata": {
                                    "name": lease_name,
                                    "namespace": self.namespace,
                                    "annotations": {
                                        "aswarm.ai/seq": str(sequence),
                                        "aswarm.ai/score": f"{score:.3f}",
                                        "aswarm.ai/node": self.node_name
                                    }
                                },
                                "spec": {
                                    "holderIdentity": self.node_name,
                                    "leaseDurationSeconds": 60,
                                    "renewTime": datetime.now(timezone.utc).isoformat()
                                }
                            }
                            
                            try:
                                self.coordination_v1.create_namespaced_lease(
                                    self.namespace, lease_data
                                )
                            except:
                                self.coordination_v1.patch_namespaced_lease(
                                    lease_name, self.namespace, lease_data
                                )
                            
                            # Fast-path for high scores
                            if score >= 0.90:
                                anomaly_data = {
                                    'score': score,
                                    'witness_count': random.randint(1, 5),
                                    'selector': f'node={self.node_name}',
                                    'event_type': 'synthetic_anomaly'
                                }
                                stats = self.fastpath_sender.send_elevation(
                                    anomaly_data,
                                    run_id=f"run-{sequence}"
                                )
                                logger.info(f"Fast-path: score={score:.3f}, seq={stats.get('seq16', 0)}")
                            
                            if sequence % 20 == 0:
                                logger.info(f"Telemetry {sequence}: score={score:.3f}")
                            
                            is_healthy = True
                            sequence += 1
                            time.sleep(0.05)  # 50ms cadence
                            
                        except Exception as e:
                            logger.error(f"Error: {e}", exc_info=True)
                            is_healthy = False
                            time.sleep(1)
            
            def main():
                start_health_server(9001)
                telemetry = DualPathTelemetry()
                telemetry.run()
            
            if __name__ == '__main__':
                main()
            EOF
            
            python /tmp/runner.py
        env:
        - name: NODE_NAME
          valueFrom:
            fieldRef:
              fieldPath: spec.nodeName
        - name: NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: FASTPATH_HOST
          value: "aswarm-pheromone"
        - name: FASTPATH_PORT
          value: "8888"
        - name: ASWARM_FASTPATH_KEY
          valueFrom:
            secretKeyRef:
              name: aswarm-fastpath-key
              key: key
        - name: ASWARM_DUPES
          value: "3"
        - name: ASWARM_GAP_MS
          value: "6"
        ports:
        - name: health
          containerPort: 9001
          protocol: TCP
        resources:
          requests:
            memory: "128Mi"
            cpu: "50m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /healthz
            port: 9001
          initialDelaySeconds: 10
          periodSeconds: 15
          timeoutSeconds: 3
        readinessProbe:
          httpGet:
            path: /healthz
            port: 9001
          initialDelaySeconds: 5
          periodSeconds: 10
          timeoutSeconds: 3
        volumeMounts:
        - name: tmp
          mountPath: /tmp
        - name: app-code
          mountPath: /app
          readOnly: true
      volumes:
      - name: tmp
        emptyDir: {}
      - name: app-code
        emptyDir: {}
      - name: code-secret
        secret:
          secretName: aswarm-code-bundle
      tolerations:
      - key: node-role.kubernetes.io/control-plane
        operator: Exists
        effect: NoSchedule
      - key: node-role.kubernetes.io/master
        operator: Exists
        effect: NoSchedule