// Package intelligence - A-SWARM Evolution Data Contracts
// Core interfaces and types for the adversarial evolution loop

package intelligence

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"math"
	"sort"
	"strings"
)

const (
	// ComputeOverallFitnessLatencyPivot is normalization point for P95 latency scoring
	ComputeOverallFitnessLatencyPivot = 100.0 // 100ms

	// Schema version for hash collision avoidance
	SpecHashVersion = "v1"

	// Diversity signature encoding version
	DiversitySigVersion = "bitset-v1"
)

// AntibodyVariant represents a candidate antibody generated by mutation
type AntibodyVariant struct {
	ID           string       `json:"id"`
	SpecHash     string       `json:"spec_hash"`      // SHA256 for stable identity
	ParentIDs    []string     `json:"parent_ids"`
	Generation   int          `json:"generation"`
	Spec         AntibodySpec `json:"spec"`           // from your CRD schema
	ProposedBy   string       `json:"proposed_by"`    // "mutation-engine@v1.0"
	DiversitySig string       `json:"diversity_sig,omitempty"`  // Base64 bitset
	CreatedAt    int64        `json:"created_at"`     // Unix timestamp
}

// ROCPoint represents a specific operating point on ROC curve
type ROCPoint struct {
	Threshold float64 `json:"threshold"`
	TPR       float64 `json:"tpr"`
	FPR       float64 `json:"fpr"`
}

// ROCSummary contains ROC analysis results
type ROCSummary struct {
	AtFPR001 *ROCPoint `json:"at_fpr_0_001,omitempty"` // Operating point at 0.1% FPR
}

// FitnessSummary contains essential metrics for population management decisions
type FitnessSummary struct {
	OverallFitness float64     `json:"overall_fitness"` // Composite score for ranking [0,1]
	ROC            *ROCSummary `json:"roc,omitempty"`   // ROC analysis when available
	P95LatencyMs   float64     `json:"p95_latency_ms"`  // 95th percentile MTTD
	StabilityScore float64     `json:"stability_score"` // Cross-environment consistency [0,1]
	SampleSize     int         `json:"sample_size"`
	ConfidenceLo   float64     `json:"confidence_lo"`   // Wilson lower bound
	ConfidenceHi   float64     `json:"confidence_hi"`   // Wilson upper bound
	BlastRadius    string      `json:"blast_radius"`    // ring-1 through ring-5
}

// PopulationState represents current evolution state for persistence/recovery
type PopulationState struct {
	Generation      int                        `json:"generation"`
	ActivePools     map[string][]string        `json:"active_pools"`    // phase -> antibody IDs
	ParentPool      []string                   `json:"parent_pool"`     // Current breeding population
	ArchivePool     []string                   `json:"archive_pool"`    // Historical best performers
	SpecHashes      map[string]string          `json:"spec_hashes"`     // variantID→specHash for recovery
	Diversity       float64                    `json:"diversity_index"` // Population diversity metric
	BestFitness     float64                    `json:"best_fitness"`    // Current generation champion
	BestFitnessByGen []float64                 `json:"best_fitness_by_gen,omitempty"` // Ring buffer for trends
	Params          PopulationConfig           `json:"params"`          // Config snapshot for this generation
	LastUpdated     int64                      `json:"last_updated"`    // Unix timestamp
}

// PopulationConfig holds tunable parameters for evolution
type PopulationConfig struct {
	// Population sizing
	ShadowPoolSize int `json:"shadow_pool_size"` // Number of variants in shadow testing
	StagedPoolSize int `json:"staged_pool_size"` // Number in staged deployment
	EliteSize      int `json:"elite_size"`       // Top performers carried forward

	// Evolution parameters
	MutationRate     float64 `json:"mutation_rate"`      // Base probability of mutation
	CrossoverRate    float64 `json:"crossover_rate"`     // Probability of crossover vs mutation
	DiversityLambda  float64 `json:"diversity_lambda"`   // Diversity penalty weight
	NoveltyEpsilon   float64 `json:"novelty_epsilon"`    // Probability of random novelty injection

	// Selection criteria
	MinTPRLowerBound float64 `json:"min_tpr_lower_bound"` // Wilson confidence lower bound threshold
	MaxFPRUpperBound float64 `json:"max_fpr_upper_bound"` // Maximum false positive rate allowed
	MinShadowHours   int     `json:"min_shadow_hours"`    // Minimum shadow period before promotion

	// Resource limits
	MaxConcurrency   int `json:"max_concurrency"`     // Max variants evaluated in parallel
	MaxGenerations   int `json:"max_generations"`     // Generational limit for safety
	GenerationBudget int `json:"generation_budget"`   // Max evaluation budget per generation
}

// PopulationManager orchestrates antibody evolution across generations
type PopulationManager interface {
	// ProposeCohort generates new candidate variants from parent specs
	ProposeCohort(ctx context.Context, parents []AntibodyVariant, size int, environment string) ([]AntibodyVariant, error)

	// IngestResults processes fitness evaluation results and updates population state
	IngestResults(ctx context.Context, results map[string]FitnessSummary) error

	// SelectNextParents chooses breeding population for next generation based on fitness + diversity
	SelectNextParents(ctx context.Context, k int) ([]AntibodyVariant, error)

	// GetSpecs retrieves current antibody specs by IDs
	GetSpecs(ctx context.Context, variantIDs []string) ([]AntibodyVariant, error)

	// Snapshot returns current population state for persistence/observability
	Snapshot(ctx context.Context) (PopulationState, error)

	// UpdateConfig applies new population parameters (for runtime tuning)
	UpdateConfig(ctx context.Context, config PopulationConfig) error

	// GetDiversityIndex computes current population diversity metric
	GetDiversityIndex(ctx context.Context) (float64, error)
}

// MutationEngine generates variants from parent antibodies
type MutationEngine interface {
	// Mutate applies genetic operators to generate variants
	Mutate(ctx context.Context, parent AntibodySpec, config MutationConfig) (AntibodySpec, error)

	// CrossOver combines features from multiple parents
	CrossOver(ctx context.Context, parents []AntibodySpec, config MutationConfig) (AntibodySpec, error)

	// ValidateSpec ensures generated specs meet safety constraints
	ValidateSpec(ctx context.Context, spec AntibodySpec) error

	// ComputeDiversitySignature generates base64 bitset for diversity calculation
	ComputeDiversitySignature(ctx context.Context, spec AntibodySpec) (string, error)
}

// MutationConfig controls genetic operator behavior
type MutationConfig struct {
	// Parameter mutation
	ParamJitterSigma float64 `json:"param_jitter_sigma"` // Standard deviation for numeric params
	ThresholdDelta   float64 `json:"threshold_delta"`    // Max delta for threshold adjustments

	// Feature mutation
	FeatureToggleProb float64 `json:"feature_toggle_prob"` // Probability of flipping binary features
	FeatureAddProb    float64 `json:"feature_add_prob"`    // Probability of adding new features
	FeatureRemoveProb float64 `json:"feature_remove_prob"` // Probability of removing features

	// Structure mutation
	StructureProb     float64 `json:"structure_prob"`      // Probability of structural changes
	WeightShuffleProb float64 `json:"weight_shuffle_prob"` // Hybrid weight rebalancing probability

	// Safety constraints - MaxComplexity is rule count + feature count + model size
	MaxComplexity    int      `json:"max_complexity"`     // Upper bound on total complexity
	MinConfidence    float64  `json:"min_confidence"`     // Minimum confidence threshold [0,1]
	ForbiddenCombos  []string `json:"forbidden_combos"`   // Blacklisted feature combinations
}

// PheromoneBundle represents shared immune memory for federation
type PheromoneBundle struct {
	BundleVersion     string                 `json:"bundle_version"`
	ClusterID         string                 `json:"cluster_id"`
	Timestamp         int64                  `json:"timestamp"`
	Antibodies        []AntibodyDigest       `json:"antibodies"`     // Compressed antibody summaries
	FPExemplars       []FalsePositiveDigest  `json:"fp_exemplars"`   // Hashed false positive examples
	Signature         string                 `json:"signature"`      // HMAC-SHA256 bundle integrity
	Algo              string                 `json:"algo"`           // "HMAC-SHA256"
	ContentEncoding   string                 `json:"content_encoding,omitempty"` // "gzip" if compressed
}

// AntibodyDigest is a compressed representation for federation
type AntibodyDigest struct {
	SpecHash       string         `json:"spec_hash"`       // SHA256 of full spec
	FitnessSummary FitnessSummary `json:"fitness_summary"`
	Lineage        LineageDigest  `json:"lineage"`
	Environment    string         `json:"environment"`     // Origin environment
}

// LineageDigest tracks evolutionary ancestry
type LineageDigest struct {
	Generation    int      `json:"generation"`
	ParentHashes  []string `json:"parent_hashes"`  // SHA256 hashes of parents
	MutationType  string   `json:"mutation_type"`  // "param_jitter", "crossover", etc.
}

// FalsePositiveDigest represents problematic detection patterns
type FalsePositiveDigest struct {
	PatternHash string  `json:"pattern_hash"` // SHA256 of triggering pattern
	Frequency   int     `json:"frequency"`    // Occurrence count
	Impact      string  `json:"impact"`       // "low", "medium", "high", "critical"
	Environment string  `json:"environment"`  // Origin environment
}

// Utility functions for diversity and similarity calculations

// ComputeJaccardSimilarity calculates Jaccard similarity between two base64 bitset signatures
func ComputeJaccardSimilarity(sig1, sig2 string) float64 {
	if sig1 == "" || sig2 == "" {
		return 0.0
	}

	// For bitset implementation - simplified version that assumes comma-separated for now
	// Real implementation should decode base64 bitsets and compute intersection/union
	features1 := make(map[string]bool)
	features2 := make(map[string]bool)

	for _, f := range strings.Split(sig1, ",") {
		f = strings.TrimSpace(f)
		if f != "" {
			features1[f] = true
		}
	}

	for _, f := range strings.Split(sig2, ",") {
		f = strings.TrimSpace(f)
		if f != "" {
			features2[f] = true
		}
	}

	// Calculate intersection and union
	intersection := 0
	union := make(map[string]bool)

	for f := range features1 {
		union[f] = true
		if features2[f] {
			intersection++
		}
	}

	for f := range features2 {
		union[f] = true
	}

	if len(union) == 0 {
		return 0.0
	}

	return float64(intersection) / float64(len(union))
}

// ComputeOverallFitness calculates composite fitness score for ranking [0,1]
func ComputeOverallFitness(summary FitnessSummary) float64 {
	// Weighted combination of key metrics
	detectionWeight := 0.35
	latencyWeight := 0.25
	stabilityWeight := 0.25
	fprPenaltyWeight := 0.10
	radiusPenaltyWeight := 0.05

	// Detection rate component (use confidence lower bound for safety)
	detectionScore := clampFloat64(summary.ConfidenceLo, 0.0, 1.0)

	// Latency component (invert and normalize - lower is better)
	latencyScore := 1.0 / (1.0 + summary.P95LatencyMs/ComputeOverallFitnessLatencyPivot)

	// Stability component
	stabilityScore := clampFloat64(summary.StabilityScore, 0.0, 1.0)

	// FPR penalty component
	fprPenalty := 0.0
	if summary.ROC != nil && summary.ROC.AtFPR001 != nil {
		// Scale FPR 0..0.02 to penalty 0..1
		fprPenalty = clampFloat64(summary.ROC.AtFPR001.FPR/0.02, 0.0, 1.0)
	}

	// Blast radius penalty component (ring-1=1.0, ring-5=0.2)
	radiusScore := 1.0 // Default if unknown
	switch summary.BlastRadius {
	case "ring-1":
		radiusScore = 1.0
	case "ring-2":
		radiusScore = 0.8
	case "ring-3":
		radiusScore = 0.6
	case "ring-4":
		radiusScore = 0.4
	case "ring-5":
		radiusScore = 0.2
	}

	// Composite score with penalty terms
	overall := detectionWeight*detectionScore +
	          latencyWeight*latencyScore +
	          stabilityWeight*stabilityScore -
	          fprPenaltyWeight*fprPenalty -
	          radiusPenaltyWeight*(1.0-radiusScore)

	// Clamp final score to [0,1] and ensure no NaNs
	result := clampFloat64(overall, 0.0, 1.0)
	if math.IsNaN(result) || math.IsInf(result, 0) {
		return 0.0 // Safety fallback for degenerate cases
	}

	return result
}

// ComputeSpecHash generates deterministic hash for antibody specification
func ComputeSpecHash(spec AntibodySpec) string {
	// Create deterministic string representation with version prefix
	var parts []string
	parts = append(parts, fmt.Sprintf("version:%s", SpecHashVersion))
	parts = append(parts, fmt.Sprintf("type:%s", spec.Detector.Type))

	if spec.Detector.Rule != nil {
		parts = append(parts, fmt.Sprintf("pattern:%s", spec.Detector.Rule.Pattern))
		parts = append(parts, fmt.Sprintf("engine:%s", spec.Detector.Rule.EngineHint))

		// Sort features for deterministic hash
		var features []string
		for k, v := range spec.Detector.Rule.Features {
			features = append(features, fmt.Sprintf("%s=%s", k, v))
		}
		sort.Strings(features)
		parts = append(parts, fmt.Sprintf("features:%s", strings.Join(features, ",")))
	}

	if spec.Detector.Model != nil {
		parts = append(parts, fmt.Sprintf("training_data:%s", spec.Detector.Model.TrainingData))

		// Serialize model features deterministically
		if len(spec.Detector.Model.Features) > 0 {
			var modelFeatures []string
			for k, v := range spec.Detector.Model.Features {
				modelFeatures = append(modelFeatures, fmt.Sprintf("%s=%v", k, v))
			}
			sort.Strings(modelFeatures)
			parts = append(parts, fmt.Sprintf("model_features:%s", strings.Join(modelFeatures, ",")))
		}
	}

	if spec.Detector.Hybrid != nil {
		parts = append(parts, fmt.Sprintf("rule_weight:%.6f", spec.Detector.Hybrid.RuleWeight))
		parts = append(parts, fmt.Sprintf("model_weight:%.6f", spec.Detector.Hybrid.ModelWeight))
	}

	// Environment and scope info
	sort.Strings(spec.Scope.Environments)
	parts = append(parts, fmt.Sprintf("envs:%s", strings.Join(spec.Scope.Environments, ",")))

	// Include namespaces and labels for complete coverage
	if len(spec.Scope.Namespaces) > 0 {
		sort.Strings(spec.Scope.Namespaces)
		parts = append(parts, fmt.Sprintf("namespaces:%s", strings.Join(spec.Scope.Namespaces, ",")))
	}

	if len(spec.Scope.Labels) > 0 {
		var labels []string
		for k, v := range spec.Scope.Labels {
			labels = append(labels, fmt.Sprintf("%s=%s", k, v))
		}
		sort.Strings(labels)
		parts = append(parts, fmt.Sprintf("labels:%s", strings.Join(labels, ",")))
	}

	parts = append(parts, fmt.Sprintf("confidence_threshold:%.6f", spec.Scope.ConfidenceThreshold))

	// Generate SHA256 hash
	combined := strings.Join(parts, "|")
	hash := sha256.Sum256([]byte(combined))
	return hex.EncodeToString(hash[:])
}

// Default configurations for production deployment

// DefaultPopulationConfig returns sensible production defaults with sanity checks
func DefaultPopulationConfig() PopulationConfig {
	config := PopulationConfig{
		ShadowPoolSize:   10,
		StagedPoolSize:   5,
		EliteSize:        3, // Must be <= ShadowPoolSize
		MutationRate:     0.15,
		CrossoverRate:    0.2,
		DiversityLambda:  0.1,
		NoveltyEpsilon:   0.05,
		MinTPRLowerBound: 0.90,
		MaxFPRUpperBound: 0.001,
		MinShadowHours:   168, // 1 week
		MaxConcurrency:   20,
		MaxGenerations:   100,
		GenerationBudget: 1000,
	}

	// Sanity check
	if config.EliteSize > config.ShadowPoolSize {
		config.EliteSize = config.ShadowPoolSize
	}

	return config
}

// DefaultMutationConfig returns safe mutation parameters
func DefaultMutationConfig() MutationConfig {
	return MutationConfig{
		ParamJitterSigma:   0.05, // 5% jitter
		ThresholdDelta:     0.1,  // ±10% threshold adjustment
		FeatureToggleProb:  0.05, // 5% chance to flip features
		FeatureAddProb:     0.02, // 2% chance to add features
		FeatureRemoveProb:  0.02, // 2% chance to remove features
		StructureProb:      0.1,  // 10% structure changes
		WeightShuffleProb:  0.1,  // 10% weight rebalancing
		MaxComplexity:      100,  // rule count + feature count + model params
		MinConfidence:      0.5,  // Minimum confidence threshold [0,1]
		ForbiddenCombos:    []string{}, // No blacklisted combos initially
	}
}

// Utility functions

// clampFloat64 constrains value to [min, max] range
func clampFloat64(value, min, max float64) float64 {
	if value < min {
		return min
	}
	if value > max {
		return max
	}
	return value
}